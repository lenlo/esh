/**
 **	ESH version 1.3
 **
 **	The Environmental Shell is intended as an intermediary between
 **	/bin/login and the activation of a user's real shell.  Its purpose
 **	is to set up a common environment for a all users on a particular
 **	system that can easily be changed by the superuser as needed.
 **
 **	By default, esh will modify the already existing environment by
 **	reading bindings from /etc/environ before exec'ing the user's
 **	personal shell.  It is intended to replace the user's real shell
 **	in /etc/passwd and will take the real shell from the user's SHELL
 **	environment variable, or from the user's ~/.shell file.
 **
 **	Lennart Lovstrand, Rank Xerox EuroPARC, Tue Jan 16 19:16:16 1990
 **	Last edited: Thu Mar  7 14:22:52 1991
 **/

#include <stdio.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/file.h>
#ifdef DEBUGTIME
#include <sys/types.h>
#include <sys/timeb.h>
#endif /* DEBUGTIME */
#include <pwd.h>

#define	SYSENVFILE	"/etc/environ"
#define USRENVFILE	"$HOME/.environ"
#define SYSSHELL	"${SHELL-/bin/csh}"
#define USRSHELL	"$HOME/.shell"
#define BIGBUFSIZ	10240
#define ENVSIZ		1024

#define TRUE		1
#define FALSE		0

#define NO_FORMAT	0
#define SH_FORMAT	1
#define CSH_FORMAT	2

extern char **environ;
extern char *index(), *rindex(), *getenv();
char *readbinding(), *interpret(), *newstr(), **bassoc(), *mkbind();
void fprintq();

char *EnvBuf[ENVSIZ];
int Debug = FALSE; /* TRUE; */

void usage(name)
    char *name;
{
    fprintf(stderr, "usage: %s [-D] [-E sysenv] [-F usrenv] [-L] [-S shell] [shell-args...]\n", name);
    exit(1);
}

/* arg should be "-A xxx yyy ..." */

void rearg(int *pargc, char ***pargv, int argi)
{
    char *arg = (*pargv)[argi];
    static char *nargv[32];
    int nargc = 0;
    char *p = arg;

    nargv[nargc++] = (*pargv)[0];

    for (;;) {
	p = index(p + 1, ' ');

	if (p == NULL)
	    break;

	*p = '\0';
	nargv[nargc++] = p + 1;
    }

    while (++argi < *pargc) {
	nargv[nargc++] = (*pargv)[argi];
    }

    *pargc = nargc;
    *pargv = nargv;
}

main(argc, argv)
    int argc;
    char **argv;
{
    extern int optind, opterr, getopt();
    extern char *optarg;
    char *sysenvfile = SYSENVFILE;
    char *usrenvfile = USRENVFILE;
    char *shell = NULL;
    char **args;
    char c, *p, **ee, **ff;
    char buf[BUFSIZ];
    int shellout = NO_FORMAT;
    int optend;
#ifdef DEBUGTIME
    struct timeb before, after;

    (void) ftime(&before);
#endif /* DEBUGTIME */

    opterr = FALSE;
    optend = FALSE;
    while (!optend && (c = getopt(argc, argv, "ABCDE:F:LS:")) != EOF) {
	switch (c) {
	  case 'A': rearg(&argc, &argv, optind); break;
	  case 'B': shellout = SH_FORMAT;	break;
	  case 'C': shellout = CSH_FORMAT;	break;
	  case 'D': Debug = TRUE;		break;
	  case 'E': sysenvfile = optarg;	break;
	  case 'F': usrenvfile = optarg;	break;
	  case 'L': argv[0][0] = '-';		break;
	  case 'S': shell = optarg;		break;
	  default:
	    /* pass arg to real shell */
	    optind--;
	    optend = TRUE;
	}
    }

    if (Debug) {
	int a;
	fprintf(stderr, "args:");
	for (a = 0; a < argc; a++) {
	    if (a == optind)
		fprintf(stderr, " |");
	    fprintf(stderr, " [%d] %s", a, argv[a]);
	}
	fprintf(stderr, "\n");
    }

    /* copy old environment into a large enough buffer and replace it */
    ee = environ;
    ff = EnvBuf;
    while (*ee != NULL && ff < EnvBuf + sizeof(EnvBuf) - 1)
	/* avoid infinite recursion -- stamp out any SHELL=esh binding */
	if (strncmp(*ee, "SHELL=", 6) == 0)
	    ee++;
	else
	    *ff++ = *ee++;
    *ff = NULL;
    environ = EnvBuf;

    /* add global environment */
    if (Debug)
	printf("[--system environment--]\n");
    readenv(interpret(sysenvfile));

    /* add private environment */
    if (Debug)
	printf("[--user environment--]\n");
    readenv(interpret(usrenvfile));

    /*
     * If the shell hasn't been given (normal case),
     * check ~/.shell to see what it should be.
     */
    if (shell == NULL) {
	shell = interpret(USRSHELL);

	if (access(shell, F_OK) < 0)
	    shell = interpret(SYSSHELL);

	if (access(shell, X_OK) < 0) {
	    /* not executable, assume text file with name of shell */
	    FILE *stream = fopen(shell, "r");

	    if (stream == NULL) {
		perror(shell);
		exit(1);
	    }

	    if (fgets(buf, sizeof(buf), stream) == NULL) {
		perror(shell);
		exit(1);
	    }

	    if ((p = index(buf, '\n')) != NULL)
		*p = '\0';

	    shell = interpret(buf);
	    (void) fclose(stream);
	}
    }

    /* rebind SHELL to point to the user-specified shell */
    if ((ee = bassoc("SHELL", environ)) == NULL) {
	*ee++ = mkbind("SHELL", shell);
	*ee = NULL;
    } else {
	/* (void) free(*ee); -- if only we knew it was malloced */
	*ee =  mkbind("SHELL", shell);
    }

    /*
     *  Only do shell source output?
     */
    switch (shellout) {
      case SH_FORMAT:
	for (ee = environ; *ee != NULL; ee++) {
	    p = index(*ee, '=');
	    if (p == NULL)
		printf("%s=; export %s\n", *ee, *ee);
	    else {
		*p = '\0';
		printf("%s=", *ee);
		if (p[1] != '\0')
		    fprintq(stdout, p + 1);
		printf("; export %s\n", *ee);
	    }
	}
	exit(0);
      case CSH_FORMAT:
	for (ee = environ; *ee != NULL; ee++) {
	    p = index(*ee, '=');
	    if (p == NULL)
		printf("setenv %s\n", *ee);
	    else {
		*p = '\0';
		printf("setenv %s ", *ee);
		if (p[1] != '\0')
		    fprintq(stdout, p + 1);
		putchar('\n');
		*p = '=';
	    }
	}
	exit(0);
    }

    /*
     * Set up args for exec'ing the new shell and replace args[0]
     * with a leading dash (if we're a login shell) and the name of the shell.
     */
    args = &argv[optind-1];
    if ((p = rindex(shell, '/')) == NULL)
	p = shell;
    /*
     * Hack Attack!  If the file begins with a dot (like .shell) and it is
     * a symlink, then replace it with the target file so that the shell
     * won't get confused about what it is
     */
    if (p[0] == '.' || (p[0] == '/' && p[1] == '.')) {
	int len = readlink(shell, buf, sizeof(buf));

	if (len >= 0) {
	    if (len == sizeof(buf))
		len--;
	    buf[len] = '\0';
	    if ((p = rindex(buf, '/')) == NULL)
		p = buf;
	}
    }
    if (argv[0][0] == '-') {
	args[0] = newstr(p);
	args[0][0] = '-';
    } else if (p == shell)
	args[0] = newstr(p);
    else
	args[0] = newstr(p + 1);

    /* the shell is dead, long live the shell! */
    if (Debug) {
	char **pp;
	printf("[exec %s:", shell);
	for (pp = args; *pp != NULL; pp++)
	    printf(" %s", *pp);
	printf("]\n");
    }
#ifdef DEBUGTIME
    (void) ftime(&after);
    fprintf(stderr, "[esh: time = %5.3f]\n",
	    (after.time + after.millitm * 0.001) -
	    (before.time + before.millitm * 0.001));
#endif /* DEBUGTIME */
    execvp(shell, args);
    perror(shell);
    execve("/bin/sh", args, environ);
    perror("/bin/sh");
    exit(1);
}

readenv(file)
    char *file;
{
    FILE *stream;
    char *binding;
    register char **ee;
#ifdef DISABLE_NONINTERACTIVE_PS1
    int interactive = isatty(0);
#endif

    if (strcmp(file, "-") == 0)
	stream = stdin;
    else {
	stream = fopen(file, "r");
	if (stream == NULL)
	    return;
    }

    while ((binding = readbinding(stream)) != NULL) {
	if (Debug)
	    fprintf(stderr, "[%s]\n", binding);
	ee = bassoc(binding[0] == '-' ? &binding[1] : binding, environ);
	if (*binding == '-'
#ifdef DISABLE_NONINTERACTIVE_PS1
	    || (!interactive && strncmp(binding, "PS1=", 4) == 0)
#endif
	    ) {
	    /* Remove binding */
	    if (*ee != NULL) {
		/* (void) free(*ee); -- if only we knew it was malloced */
		do {
		    ee[0] = ee[1];
		} while (*ee++ != NULL);
	    }
	} else if (*ee == NULL) {
	    if (ee < &EnvBuf[ENVSIZ - 1]) {
		*ee++ = binding;
		*ee = NULL;
	    }
	} else {
	    /* (void) free(*ee); -- if only we knew it was malloced */
	    *ee = binding;
	}
    }

    if (stream != stdin)
	(void) fclose(stream);
    return;
}

/*
 *	Make a freshly malloc'ed environment variable binding.
 *	mkbind("foo", "bar") => "foo=bar"
 */
char *
mkbind(name, value)
    char *name, *value;
{
    char *buf;

    buf = (char *) malloc(strlen(name) + 1 + strlen(value) + 1);
    if (buf == NULL) {
	perror("malloc");
	exit(1);
    }

    sprintf(buf, "%s=%s", name, value);

    return buf;
}

/*
 *	Determine if a certain "[name]" conditional applies to us.
 */
int conditional(const char *name)
{
    static char *username = NULL;
    static char *hostname = NULL;
    int len;

    if (username == NULL) {
	static char hostbuf[256];

	username = getlogin();
	if (username == NULL) {
	    struct passwd *pw = getpwuid(getuid());
	    if (pw != NULL)
		username = pw->pw_name;
	}

	if (gethostname(hostbuf, sizeof(hostbuf)) == 0)
	    hostname = hostbuf;

	if (Debug)
	    printf("# username = %s, hostname = %s\n", username, hostname);
    }

    if (strcasecmp(name, "*") == 0 || strcasecmp(name, "all") == 0)
	return TRUE;

    if (strcasecmp(name, username) == 0)
	return TRUE;

    if (strcasecmp(name, hostname) == 0)
	return TRUE;

    len = strlen(name);
    if (strncasecmp(name, hostname, len) == 0 && hostname[len] == '.')
	return TRUE;

    return FALSE;
}


/*
 *	Read a binding from the stream and return it in the form "name=value".
 *	The format of the file is: name<whitespace>value<newline> with
 *	special processing for #, $, \.
 *
 *	Example:
 *		" name [=] value\"
 *		"	\#value\$value # comment"
 *		=> "name=value#value$value"
 */
char *
readbinding(stream)
    FILE *stream;
{
    char *p, *b, buf[BIGBUFSIZ];
    char *name, *value;
#ifdef AUTO_PRUNE_PATH
    int pathp = FALSE;
#endif /* AUTO_PRUNE_PATH */
    int ignore = FALSE;

    name = value = NULL;
    b = buf;
    while (fgets(b, buf + sizeof(buf) - b, stream) != NULL) {

	/* find newline and nuke it */
	p = index(b, '\n');
	if (p == NULL)
	    fprintf(stderr,
		    "Warning: Line too long -- truncated after %d chars\n",
		    sizeof(buf)-1);
	else
	    *p = '\0';

	/* find unquoted sharp (#) and nuke rest of line */
	for (p = b; *p != '\0'; p++) {
	    if (*p == '\\' && p[1] == '#')
		p++;
	    else if (*p == '#') {
		*p = '\0';
		break;
	    }
	}

	p = b;
	while (*p != '\0' && isspace(*p))
	    p++;
	if (*p == '\0')
	    continue;

	/* Is it a conditional "[name]" section? */
	if (*p == '[') {
	    char buf[256];

	    /* Assume that we will ignore this section */
	    ignore = TRUE;

	    for (b = buf, p++; *p != '\0'; p++) {
		if (isspace(*p) || *p == ']') {
		    *b = '\0';
		    if (conditional(buf)) {
			ignore = FALSE;
			break;
		    }
		    while (*p != '\0' && isspace(*p)) p++;
		    b = buf;

		    if (*p == ']')
			break;
		} else if (b < &buf[sizeof(buf)-1]) {
		    *b++ = *p;
		}
	    }
	    continue;
	}

	if (ignore)
	    continue;

	/* got a name already? */
	if (name == NULL) {
	    /* find beginning of name */
	    name = p;

	    /* find end of name */
	    while (*p != '\0' && !isspace(*p) && *p != '=')
		p++;
	    if (*p == '\0')
		return mkbind(name, "");
	    *p++ = '\0';

#ifdef AUTO_PRUNE_PATH
	    /* is this a path variable? */
	    if (p - 5 >= b && strncmp(p - 5, "PATH", 4) == 0)
		pathp = TRUE;
#endif /* AUTO_PRUNE_PATH */

	    b = p;
	}

	/* find beginning of value */
	while (*p != '\0' && isspace(*p))
	    p++;

	/* compact buffer if necessary */
	if (p > b) {
	    strcpy(b, p);
	    p = b;
	}

	if (value == NULL)
	    value = p;

	/* empty/end of value? */
	if (*p == '\0')
	    break;

	/* find end of value */
	p += strlen(p) - 1;
	if (*p == '\\') {
	    /* handle continuation */
	    *p = '\0';
	    b = p;
	    continue;
	} else {
	    /* remove trailing blanks */
	    while (p > value && isspace(*p))
		p--;
	    /* last space quoted?  if so, keep it */
	    if (*p == '\\')
		p++;
	    p[1] = '\0';
	    break;
	}
    }
    if (name == NULL)
	return NULL;
#ifdef AUTO_PRUNE_PATH
    if (pathp) {
	extern char *ppath();
	char *bind;

	value = ppath(interpret(value));
	bind = mkbind(name, value);
	free(value);
	return bind;
    } else
#endif /* AUTO_PRUNE_PATH */
	return mkbind(name, interpret(value));
}

/*
 *	Interpret the given string with respect to variables etc.
 *	(Result is static string)
 */
char *
interpret(string)
    char *string;
{
    static char buf[BIGBUFSIZ];
    char *p, *q;

    p = string;
    q = buf;

    while (*p != '\0' && q < &buf[sizeof(buf)] - 1) {
	switch (*p++) {
	  case '$':
	    expand(&p, &q, &buf[sizeof(buf)] - q);
	    break;
	  case '`':
	    compute(&p, &q, &buf[sizeof(buf)] - q);
	    break;
	  case '\\':
	    switch (*p) {
	      case 'n': *q++ = '\n'; break;
	      case 'r': *q++ = '\r'; break;
	      case 't': *q++ = '\t'; break;
	      default:
		if (isdigit(*p))
		    *q++ = strtol(p, &p, 8);
		else
		    *q++ = *p++;
	    }
	    break;
	  default:
	    *q++ = *(p-1);
	}
    }
    *q = '\0';

    return buf;
}

/*
 *	Parse and expand the given variable that src points to and
 *	copy the result into dst.  Update both src and dst pointers.
 *	Eg. expand("$foo/baz", "xxxxxxxx", 8) with environ = {"foo=bar", NULL}
 *	would give "$foo/baz", "barxxxxx"
 *	      with      ^=src      ^=dst
 */
expand(src, dst, dstlen)
    char **src, **dst;
    int dstlen;
{
    register char *p, *q;
    char delim, *value, *defvalue = "";
    int brace = FALSE;

    if (**src == '{' || **src == '(') {
	(*src)++;
	brace = TRUE;
    }

    p = *src;
    while (*p != '\0' && (isalnum(*p) || *p == '_')) p++;

    delim = *p;
    *p = '\0';
    value = getenv(*src);
    if (brace) {
	*p = delim;
	if (delim != '\0' && delim != '}' && delim != ')')
	    defvalue = ++p;
	while (*p != '\0' && *p != '}' && *p != ')') p++;
	delim = *p;
	*p = '\0';
    }
    *src = p;

    if (value == NULL)
	value = defvalue;

    /* copy value to dst */
    for (p = value, q = *dst; *p != '\0' && dstlen > 0; p++, q++, dstlen--)
	*q = *p;

    /* put back source delimiter update pointers */
    **src = delim;
    if (brace && (delim == '}' || delim == ')'))
	(*src)++;
    *dst = q;
}

/*
 *	Parse and compute the given command by running it through a pipe and
 *	picking up the result.  Will update both src and dst pointers.
 *	Eg. compute("`arch`/foo", "xxxxxxxx", 8)
 *	would give  "`arch`/foo", "sun4xxxx"
 *	      with         ^=src       ^=dst
 */
compute(src, dst, dstlen)
    char **src, **dst;
    int dstlen;
{
    char *p, *q, delim;
    FILE *pipe;

    p = index(*src, '`');
    if (p == NULL)
	p = *src + strlen(*src);
    delim = *p;
    *p = '\0';

    pipe = popen(*src, "r");
    if (pipe == NULL) {
	perror(*src);
    } else {
	if (fgets(*dst, dstlen, pipe) == NULL)
	    **dst = '\0';
	if ((q = index(*dst, '\n')) != NULL)
	    *q = '\0';

	pclose(pipe);
    }

    *p = delim;
    if (delim != '\0')
	p++;

    *src = p;
    *dst += strlen(*dst);
}

/*
 *	A version of assoc(iate) for foo=bar type bindings.
 *	Eg. bassoc("foo", {"abc=def", "foo=bar", NULL}) => {"foo=bar", ...}
 *	    bassoc("foo=xyz", {"abc=def", "foo=bar", NULL}) => {"foo=bar", ...}
 *	    bassoc("baz", {"abc=def", "foo=bar", NULL}) => {NULL}
 */
char **
bassoc(key, environ)
    char *key;
    char **environ;
{
    register char **ee;
    register char *p, *q;

    for (ee = environ; *ee != NULL; ee++) {
	for (p = key, q = *ee; *p == *q; p++, q++)
	    if (*p == '\0' || *p == '=')
		break;
	if ((*p == '\0' || *p == '=') && (*q == '\0' || *q == '='))
	    break;
    }

    return ee;
}

/*
 *	Print and automatically quote a string (sh/csh syntax).
 */
void
fprintq(stream, string)
    FILE *stream;
    char *string;
{
    char *p;

    putc('\'', stream);
    for (p = string; *p != '\0'; p++)
	if (*p == '\'')
	    fputs("'\"'\"'", stream);
	else
	    putc(*p, stream);
    putc('\'', stream);
}

/*
 *	Copy the specified string into a newly malloced space.
 */
char *
newstr(string)
    char *string;
{
    char *result;

    result = (char *) malloc(strlen(string) + 1);
    if (result == NULL) {
	perror("malloc");
	exit(1);
    }

    (void) strcpy(result, string);

    return result;
}
