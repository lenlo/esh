/**
 **	ESH version 1.3
 **
 **	The Environmental Shell is intended as an intermediary between
 **	/bin/login and the activation of a user's real shell.  Its purpose
 **	is to set up a common environment for a all users on a particular
 **	system that can easily be changed by the superuser as needed.
 **
 **	By default, esh will modify the already existing environment by
 **	reading bindings from /etc/environ before exec'ing the user's
 **	personal shell.  It is intended to replace the user's real shell
 **	in /etc/passwd and will take the real shell from the user's SHELL
 **	environment variable, or from the user's ~/.shell file.
 **
 **	Lennart Lovstrand, Rank Xerox EuroPARC, Tue Jan 16 19:16:16 1990
 **	Last edited: Thu Mar  7 14:22:52 1991
 **/

#include <stdio.h>
#include <ctype.h>
#include <sys/file.h>
#ifdef DEBUGTIME
#include <sys/types.h>
#include <sys/timeb.h>
#endif DEBUGTIME

#define	SYSENVFILE	"/etc/environ"
#define USRENVFILE	"$HOME/.environ"
#define SYSSHELL	"/bin/csh"
#define USRSHELL	"$HOME/.shell"
#define BIGBUFSIZ	(10*BUFSIZ)
#define ENVSIZ		1024

#define TRUE		1
#define FALSE		0

extern char **environ;
extern char *index(), *rindex(), *getenv();
char *readbinding(), *interpret(), *newstr(), **bassoc(), *mkbind();

char *EnvBuf[ENVSIZ];
int Debug = FALSE;

usage(name)
    char *name;
{
    fprintf(stderr, "usage: %s [-D] [-E sysenv] [-F usrenv] [-L] [-S shell] [shell-args...]\n", name);
    exit(1);
}

main(argc, argv)
    int argc;
    char **argv;
{
    extern int optind, opterr, getopt();
    extern char *optarg;
    char *sysenvfile = SYSENVFILE;
    char *usrenvfile = USRENVFILE;
    char *shell = NULL;
    char **args;
    char c, *p, **ee, **ff;
    char buf[BUFSIZ];
    int loginsh, optend;
#ifdef DEBUGTIME
    struct timeb before, after;

    (void) ftime(&before);
#endif DEBUGTIME

    opterr = FALSE;
    optend = FALSE;
    while (!optend && (c = getopt(argc, argv, "DE:F:LS:")) != EOF) {
	switch (c) {
	  case 'D': Debug = TRUE;		break;
	  case 'E': sysenvfile = optarg;	break;
	  case 'F': usrenvfile = optarg;	break;
	  case 'L': argv[0][0] = '-';		break;
	  case 'S': shell = optarg;		break;
	  default:
	    /* pass arg to real shell */
	    optind--;
	    optend = TRUE;
	}
    }

    /* we're only supposed to do this as a login shell with no args */
    loginsh = (argv[0][0] == '-');

    /* copy old environment into a large enough buffer and replace it */
    ee = environ;
    ff = EnvBuf;
    while (*ee != NULL && ff < EnvBuf + sizeof(EnvBuf) - 1)
#ifdef notdef
	/* avoid infinite recursion -- stamp out any SHELL=esh binding */
	if (loginsh && strncmp(*ee, "SHELL=", 6) == 0)
	    ee++;
	else
#endif notdef
	    *ff++ = *ee++;
    *ff = NULL;
    environ = EnvBuf;

    if (loginsh) {
	/* add global environment */
	if (Debug)
	    printf("[--system environment--]\n");
	readenv(interpret(sysenvfile));

	/* add private environment */
	if (Debug)
	    printf("[--user environment--]\n");
	readenv(interpret(usrenvfile));
    }

    /*
     * If the shell hasn't been given (normal case),
     * check ~/.shell to see what it should be.
     */
    if (shell == NULL) {
	shell = interpret(USRSHELL);

	if (access(shell, F_OK) < 0)
	    shell = interpret(SYSSHELL);

	if (access(shell, X_OK) < 0) {
	    /* not executable, assume text file with name of shell */
	    FILE *stream = fopen(shell, "r");

	    if (stream == NULL) {
		perror(shell);
		exit(1);
	    }

	    if (fgets(buf, sizeof(buf), stream) == NULL) {
		perror(shell);
		exit(1);
	    }

	    if ((p = index(buf, '\n')) != NULL)
		*p = '\0';

	    shell = interpret(buf);
	    (void) fclose(stream);
	}
    }

    /* rebind SHELL to point to the user-specified shell */
    if ((ee = bassoc("SHELL", environ)) == NULL) {
	*ee++ = mkbind("SHELL", shell);
	*ee = NULL;
    } else {
	/* (void) free(*ee); -- if only we knew it was malloced */
	*ee =  mkbind("SHELL", shell);
    }

    /*
     * Set up args for exec'ing the new shell and replace args[0]
     * with a leading dash (if we're a login shell) and the name of the shell.
     */
    args = &argv[optind-1];
    if ((p = rindex(shell, '/')) == NULL)
	p = shell;
    /*
     * Hack Attack!  If the file begins with a dot (like .shell) and it is
     * a symlink, then replace it with the target file so that the shell
     * won't get confused about what it is
     */
    if (p[0] == '.' || (p[0] == '/' && p[1] == '.')) {
	int len = readlink(shell, buf, sizeof(buf));

	if (len >= 0) {
	    if (len == sizeof(buf))
		len--;
	    buf[len] = '\0';
	    if ((p = rindex(buf, '/')) == NULL)
		p = buf;
	}
    }
    if (loginsh) {
	args[0] = newstr(p);
	args[0][0] = '-';
    } else
	args[0] = newstr(p + 1);

    /* the shell is dead, long live the shell! */
    if (Debug) {
	char **pp;
	printf("[exec %s:", shell);
	for (pp = args; *pp != NULL; pp++)
	    printf(" %s", *pp);
	printf("]\n");
    }
#ifdef DEBUGTIME
    (void) ftime(&after);
    fprintf(stderr, "[esh: time = %5.3f]\n",
	    (after.time + after.millitm * 0.001) -
	    (before.time + before.millitm * 0.001));
#endif DEBUGTIME
    execve(shell, args, environ);
    perror(shell);
    execve("/bin/sh", args, environ);
    perror("/bin/sh");
    exit(1);
}

readenv(file)
    char *file;
{
    FILE *stream;
    char *binding;
    register char **ee;

    if (strcmp(file, "-") == 0)
	stream = stdin;
    else {
	stream = fopen(file, "r");
	if (stream == NULL)
	    return;
    }

    while ((binding = readbinding(stream)) != NULL) {
	if (Debug)
	    fprintf(stderr, "[%s]\n", binding);
	ee = bassoc(binding, environ);
	if (*ee == NULL) {
	    if (ee < EnvBuf + sizeof(EnvBuf) - 1) {
		*ee++ = binding;
		*ee = NULL;
	    }
	} else {
	    /* (void) free(*ee); -- if only we knew it was malloced */
	    *ee = binding;
	}
    }

    if (stream != stdin)
	(void) fclose(stream);
    return;
}

/*
 *	Make a freshly malloc'ed environment variable binding.
 *	mkbind("foo", "bar") => "foo=bar"
 */
char *
mkbind(name, value)
    char *name, *value;
{
    char *buf;

    buf = (char *) malloc(strlen(name) + 1 + strlen(value) + 1);
    if (buf == NULL) {
	perror("malloc");
	exit(1);
    }

    sprintf(buf, "%s=%s", name, value);

    return buf;
}

/*
 *	Read a binding from the stream and return it in the form "name=value".
 *	The format of the file is: name<whitespace>value<newline> with
 *	special processing for #, $, \.
 *
 *	Example:
 *		" name [=] value\"
 *		"	\#value\$value # comment"
 *		=> "name=value#value$value"
 */
char *
readbinding(stream)
    FILE *stream;
{
    char *p, *b, buf[BIGBUFSIZ];
    char *name, *value;
#ifdef AUTO_PRUNE_PATH
    int pathp = FALSE;
#endif AUTO_PRUNE_PATH

    name = value = NULL;
    b = buf;
    while (fgets(b, buf + sizeof(buf) - b, stream) != NULL) {

	/* find newline and nuke it */
	p = index(b, '\n');
	if (p == NULL)
	    fprintf(stderr,
		    "Warning: Line too long -- truncated after %d chars\n",
		    sizeof(buf)-1);
	else
	    *p = '\0';

	/* find unquoted sharp (#) and nuke rest of line */
	for (p = b; *p != '\0'; p++) {
	    if (*p == '\\' && p[1] == '#')
		p++;
	    else if (*p == '#') {
		*p = '\0';
		break;
	    }
	}

	p = b;

	/* got a name already? */
	if (name == NULL) {
	    /* find beginning of name */
	    while (*p != '\0' && isspace(*p))
		p++;
	    if (*p == '\0')
		continue;
	    name = p;

	    /* find end of name */
	    while (*p != '\0' && !isspace(*p) && *p != '=')
		p++;
	    if (*p == '\0')
		return mkbind(name, "");
	    *p++ = '\0';

#ifdef AUTO_PRUNE_PATH
	    /* is this a path variable? */
	    if (p - 5 >= b && strncmp(p - 5, "PATH", 4) == 0)
		pathp = TRUE;
#endif AUTO_PRUNE_PATH

	    b = p;
	}

	/* find beginning of value */
	while (*p != '\0' && isspace(*p))
	    p++;

	/* compact buffer if necessary */
	if (p > b) {
	    strcpy(b, p);
	    p = b;
	}

	if (value == NULL)
	    value = p;

	/* empty/end of value? */
	if (*p == '\0')
	    break;

	/* find end of value */
	p += strlen(p) - 1;
	if (*p == '\\') {
	    /* handle continuation */
	    *p = '\0';
	    b = p;
	    continue;
	} else {
	    /* remove trailing blanks */
	    while (p > value && isspace(*p))
		p--;
	    /* last space quoted?  if so, keep it */
	    if (*p == '\\')
		p++;
	    p[1] = '\0';
	    break;
	}
    }
    if (name == NULL)
	return NULL;
#ifdef AUTO_PRUNE_PATH
    if (pathp) {
	extern char *ppath();
	char *bind;

	value = ppath(interpret(value));
	bind = mkbind(name, value);
	free(value);
	return bind;
    } else
#endif AUTO_PRUNE_PATH
	return mkbind(name, interpret(value));
}

/*
 *	Interpret the given string with respect to variables etc.
 *	(Result is static string)
 */
char *
interpret(string)
    char *string;
{
    static char buf[BIGBUFSIZ];
    char *p, *q;

    p = string;
    q = buf;

    while (*p != '\0' && q < &buf[sizeof(buf)] - 1) {
	switch (*p++) {
	  case '$':
	    expand(&p, &q, &buf[sizeof(buf)] - q);
	    break;
	  case '`':
	    compute(&p, &q, &buf[sizeof(buf)] - q);
	    break;
	  case '\\':
	    switch (*p) {
	      case 'n': *q++ = '\n'; break;
	      case 'r': *q++ = '\r'; break;
	      case 't': *q++ = '\t'; break;
	      default:
		if (isdigit(*p))
		    *q++ = strtol(p, &p, 8);
		else
		    *q++ = *p++;
	    }
	    break;
	  default:
	    *q++ = *(p-1);
	}
    }
    *q = '\0';

    return buf;
}

/*
 *	Parse and expand the given variable that src points to and
 *	copy the result into dst.  Update both src and dst pointers.
 *	Eg. expand("$foo/baz", "xxxxxxxx", 8) with environ = {"foo=bar", NULL}
 *	would give "$foo/baz", "barxxxxx"
 *	      with      ^=src      ^=dst
 */
expand(src, dst, dstlen)
    char **src, **dst;
    int dstlen;
{
    register char *p, *q;
    char delim, *value, *defvalue = "";
    int brace = FALSE;

    if (**src == '{' || **src == '(') {
	(*src)++;
	brace = TRUE;
    }

    p = *src;
    while (*p != '\0' && (isalnum(*p) || *p == '_')) p++;

    delim = *p;
    *p = '\0';
    value = getenv(*src);
    if (brace) {
	*p = delim;
	if (delim != '\0' && delim != '}' && delim != ')')
	    defvalue = ++p;
	while (*p != '\0' && *p != '}' && *p != ')') p++;
	delim = *p;
	*p = '\0';
    }
    *src = p;

    if (value == NULL)
	value = defvalue;

    /* copy value to dst */
    for (p = value, q = *dst; *p != '\0' && dstlen > 0; p++, q++, dstlen--)
	*q = *p;

    /* put back source delimiter update pointers */
    **src = delim;
    if (brace && (delim == '}' || delim == ')'))
	(*src)++;
    *dst = q;
}

/*
 *	Parse and compute the given command by running it through a pipe and
 *	picking up the result.  Will update both src and dst pointers.
 *	Eg. compute("`arch`/foo", "xxxxxxxx", 8)
 *	would give  "`arch`/foo", "sun4xxxx"
 *	      with         ^=src       ^=dst
 */
compute(src, dst, dstlen)
    char **src, **dst;
    int dstlen;
{
    char *p, *q, delim;
    FILE *pipe;

    p = index(*src, '`');
    if (p == NULL)
	p += strlen(p);
    delim = *p;
    *p = '\0';

    pipe = popen(*src, "r");
    if (pipe == NULL) {
	perror(*src);
    } else {
	if (fgets(*dst, dstlen, pipe) == NULL)
	    **dst = '\0';
	if ((q = index(*dst, '\n')) != NULL)
	    *q = '\0';

	pclose(pipe);
    }

    *p = delim;
    if (delim != '\0')
	p++;

    *src = p;
    *dst += strlen(*dst);
}

/*
 *	A version of assoc(iate) for foo=bar type bindings.
 *	Eg. bassoc("foo", {"abc=def", "foo=bar", NULL}) => {"foo=bar", ...}
 *	    bassoc("foo=xyz", {"abc=def", "foo=bar", NULL}) => {"foo=bar", ...}
 *	    bassoc("baz", {"abc=def", "foo=bar", NULL}) => {NULL}
 */
char **
bassoc(key, environ)
    char *key;
    char **environ;
{
    register char **ee;
    register char *p, *q;

    for (ee = environ; *ee != NULL; ee++) {
	for (p = key, q = *ee; *p == *q; p++, q++)
	    if (*p == '\0' || *p == '=')
		break;
	if ((*p == '\0' || *p == '=') && (*q == '\0' || *q == '='))
	    break;
    }

    return ee;
}

/*
 *	Copy the specified string into a newly malloced space.
 */
char *
newstr(string)
    char *string;
{
    char *result;

    result = (char *) malloc(strlen(string) + 1);
    if (result == NULL) {
	perror("malloc");
	exit(1);
    }

    (void) strcpy(result, string);

    return result;
}
